// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

/**
 * Logically the same as Binary, but the internal representation uses a view
 * struct that contains the string length and either the string's entire data
 * inline (for small strings) or an inlined prefix, an index of another buffer,
 * and an offset pointing to a slice in that buffer (for non-small strings).
 *
 * Since it uses a variable number of data buffers, each Field with this type
 * must have a corresponding entry in `variadicBufferCounts`.
 */
export class BinaryView {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):BinaryView {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsBinaryView(bb:flatbuffers.ByteBuffer, obj?:BinaryView):BinaryView {
  return (obj || new BinaryView()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsBinaryView(bb:flatbuffers.ByteBuffer, obj?:BinaryView):BinaryView {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new BinaryView()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static startBinaryView(builder:flatbuffers.Builder) {
  builder.startObject(0);
}

static endBinaryView(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createBinaryView(builder:flatbuffers.Builder):flatbuffers.Offset {
  BinaryView.startBinaryView(builder);
  return BinaryView.endBinaryView(builder);
}
}
